Historically, automatic analysis techniques for parallel programs started with
analysis of models of systems.
A programmer wishing to use such a tool would either start by creating a model
of the system (in the specification step of the development), and then provide
an executable implementation for this model or, if they already had a working
product, they would have to create a model in order to analyze it.
Such tools include for example \cite{spin}, \cite{divine-mc}, \cite{ltsmin?}, \cite{uppall?}, \cite{TODO...}.
Such an approach requires an extra investment in the modelling phase and, even
if analysis of the model concludes it is correct, it does not prove that the
final product is indeed correct.

Later, with the improvement of both analysis techniques, as well as overall
improvement in available computing power, tools which analyse programs written
in mainstream programming languages become available.
Early examples of such tools are \TODO{…}.

Since 2012, the Software Verification Competition (SV-COMP)~\cite{svc2020} aims
to showcase tools which support direct verification of software written in C
and Java.
While it includes mostly sequential programs, there is also a subcategory for
parallel C programs in SV-COMP.

We will now focus in more details on automatic techniques for verification of
parallel programs.

\section{Explicit-State Model Checking}

Explicit-state model checking is based on exhaustive exploration of the
state-space graph \cite{TODO}.
It checks that a given (finite-state) system satisfies given property.
The property is often given by an LTL formula and the automata-based approach
to LTL verification is used (i.e., the problem is reduced to the problem of
repeated reachability of a state in the state-space graph).
In the special case of safety properties, it is sufficient to perform graph
search for a state which violates the safety property, for example using the
depth-first search algorithm, or any other graph search.

The advantage of explicit-state model checking is that it is conceptually easy
to apply it to verification of parallel programs, as the interleaving semantics
of thread naturally gives rise to the state space graph. \TODO{...?}

In practice, explicit-state model checking is prone to the \emph{state-space
explosion} problem: the number of states in the state-space graph of a
reasonable system can easily be so big it is not possible to store the state
space in the available memory.
Since the algorithm which explores the state-space graph needs to detect which
states were already seen to ensure termination, the state space explosion
problem can significantly limit capabilities of explicit-state model checking.

To mitigate state-space explosion, several state-space reduction techniques
were introduced.
Using these techniques, it is possible to explore only some of the states of
the state space in such a way that the property holds for these states if and
only if it holds for the entire state space.
These reduction techniques include \emph{Partial Order Reduction} (POR), which
can eliminate some states by exploring independent event only in one particular
order.
Another example consists of various variants of \emph{\TODO{Lipton's?}
reduction}~\cite{TODO} (also called $\tau$-reduction~\cite{TODO}), which can
coalesce a path in the state space into a single edge and hide all intermediate
states, provided that the resulting edge has at most one action which can
interact with other actions in the state space.
Finally, there are variants of \emph{symmetry reductions}, for example the
\emph{heap-symmetry} reduction, which makes it possible to coalesce states
which differ only in non-interesting properties, for example in the order in
which memory objects were allocated.
These state space reduction techniques can reduce the number of states by
several orders of magnitude~\cite{TODO}, and therefore enable verification of
realistic (but still relatively small) programs.

To further improve capabilities of explicit-state model checking, several
techniques for compact representation of the set of visited states were
introduced.
These techniques include \emph{hash compaction}~\cite{TODO}, which is an
incomplete technique which stores hashes of states instead of storing the
entries states (and therefore can omit some parts of the state space if there
is hash collision), \emph{probabilistic storage of states}\TODO{...}, and
\emph{lossless compression techniques}~\cite{RSB15TC,TODO}.

\TODO{data} While explicit-state model checking can easily represent
control-flow nondeterminism, it is not well suited for data nondeterminism, as
it is not practical to explicitly enumerate all possible values of data
domains.
Therefore, if data nondeterminism is required, it is required to combine explicit-state model checking with some technique for symbolic of abstract data representation \TODO{...}.

Among the various tools which use explicit-state model checking as its basis,
there are \TODO{...}, and our own tool DIVINE~\cite{DIVINEToolPaper2017}.
DIVINE uses dynamic $\tau+$ reduction~\cite{TODO}, heap symmetry reduction, and
efficient representation of state space by memory graphs~\cite{RSCB2018}, to
tackle realistic programs.
Furthermore, DIVINE has support for symbolic and abstract representation of
data~\cite{TODO}, can analyse programs running under the \xtso memory model
(\autoref{chap:mm}, \cite{SB2018x86tso}), and can detect nontermination of
parallel programs (\autoref{chap:lnterm}, \cite{SB2019}).
DIVINE has also good support for the C and C++ languages, including support for
the standard libraries and C++ exceptions (\autoref{chap:lang},
\cite{SRB2017}).

\section{Stateless Model Checking}

\TODO{from TEDI}

Stateless Model Checking methods are intended for safety analysis of
terminating programs in real-world programming languages~\cite{Godefroid1997}. They employ Dynamic Partial Order Reduction (DPOR)
to avoid exploring equivalent runs of the program~\cite{Flanagan2005dpor} and the works concerning relaxed memory models
in this setting often discuss interlay between DPOR and relaxed memory
model in length.

A stateless model checking approach to the analysis of programs running
under the C++11 memory model (with the exception of release-consume
synchronization) is presented in~\cite{Norris2013}. It uses custom
implementation of C++ thread and atomic libraries to produce binaries
which perform the analysis. It lazily builds relations between memory
operations in the form of a \emph{modification order graph}. This
representation prevents exploration of infeasible executions as well as
unnecessary distinction between equivalent executions. Furthermore, as
the C++ memory model allows reordering of reads with future operations,
the authors propose to simulate this by propagating stored values to
previous loads and validating this speculation (which does not simulate
out-of-thin-air values). The paper includes a long discussion on
features of the C++ memory model and the corresponding implementation in
\textsc{CDSChecker}, which is usable for (small) unit tests of
concurrent data structures written in C11 or C++11.

In~\cite{Zhang2015} the authors focus mostly on modelling of TSO and PSO
and its interplay with DPOR. They combine modelling of thread scheduling
nondeterminism and memory model nondeterminism using store buffers to a
common framework. This is done by adding store buffers to the program
and adding shadow thread for each store buffer which is responsible for
flushing contents of this buffer to the memory. The proposed approach is
implemented in the tool \emph{rInspect}, which is an LLVM-based
stateless model checker which supports both unbounded store buffers and
buffer bounding (however, as it is a stateless model checker, it works
only on programs which terminate).

Another approach to combining TSO and PSO analysis with stateless model
checking is presented in~\cite{Abdulla2015}. In this work executions are
represented by chronological traces which capture dependencies required
to represent interaction between memory actions. These chronological
traces are acyclic relations and therefore can be used for DPOR,
including the optimal DPOR which explores exactly one execution in the
equivalence class of the partial order~\cite{Abdulla2014}. The advantage
of this approach is that for robust programs, using the optimal DPOR
algorithm with chronological traces should produce the same number of
executions under SC as under relaxed memory model. The proposed approach
is implemented in an LLVM-based tool Niddhugg, which supports analysis
of C programs with pthreads parallelism and with a bounded execution
length.

\section{Bounded Model Checking}

\section{K-Induction, IC3, …}

\section{Symbolic Execution}

\section{Abstraction-Based Techniques}

\section{Sequentialization Techniques}

\section{Systematic Testing}

\section{XXX}

\section{Real-World Parallel Programs}


\section{Relaxed Memory Models}

There are numerous techniques for analysis of programs with respect to relaxed memory.

\paragraph{Verification of Absence of SC Violations}

For these methods, the question is whether a program, when running under a relaxed memory model, exhibits any runs not possible under sequential consistency.
This problem is explored under many names, e.g. (TSO-)safety~\cite{Burckhardt2008}, robustness~\cite{Bouajjani2013,Derevenetc2014}, stability~\cite{Alglave2011}, and monitoring of sequential consistency~\cite{Burnim2011}.
A similar techniques are used in \cite{Yang2004} to detect data races in Java programs.
A related problem of correspondence between a parallel and sequential implementation of a data structure is explored in~\cite{Ou2017}.
Some of these techniques can also be used to insert memory fences into the programs to recover sequential consistency.

Neither of these techniques is directly comparable to our method.
For these techniques, a program is incorrect if it exhibits relaxed behavior, while for us, it is incorrect if it violates specification (e.g., assertion safety and memory safety).
In practice, the appearance of relaxed behavior is often not a problem, provided the overall behavior of the data structure or algorithm matches desired specification.
In many lock-free data structures, a relaxed behavior is essential to achieving high performance.

\paragraph{Direct Analysis Techniques}

There are multiple methods for analysis of relaxed memory models based on program transformation.
In~\cite{Alglave2013} a transformation-based technique for the x86, POWER, and ARM memory models is presented.
Another approach to program transformation is taken in~\cite{Atig2011}, in this case, the transformation uses context switch bounding but not buffer bounding, and it uses additional copies for shared variables for TSO simulation.
In~\cite{Abdulla2017} the context-bounded analysis using transformation is applied to the POWER memory model.
Our work in~\cite{SRB15weakmem} presents a transformation of LLVM bitcode to simulate buffer-bounded \xtso runs; compared to this work it has significantly less efficient implementation of the \xtso simulation.

A stateless model checking~\cite{Godefroid1997} approach to the analysis of programs running under the C++11 memory model (except for the release-consume synchronization) is presented in~\cite{Norris2013}.
In~\cite{Zhang2015} the authors focus mostly on modeling of TSO and PSO and its interplay with dynamic partial order reduction (DPOR, \cite{Flanagan2005dpor}).
They combine modeling of thread scheduling nondeterminism and memory model nondeterminism using store buffers to a common framework by adding shadow thread for each store buffer which is responsible for flushing contents of this buffer to the memory.
Another approach to combining TSO and PSO analysis with stateless model checking is presented in~\cite{Abdulla2015}.
The advantage of this approach is that for a program without relaxed behavior it should produce no additional traces compared to sequential consistency.
Another approach to stateless model checking is taken in \cite{Kokologiannakis2017}, which uses execution graphs to explore all behavior of a C/C++ program under a modified C++11 memory model without exploring its interleaving directly.

So far, all of the described techniques used some kind of bounding to achieve efficiency -- either bounding number of reordered operations, number of context switches, or number of iterations of loops.
An unbounded approach to verification of programs under TSO is presented in~\cite{Linden2010}.
It uses store buffers represented by automata and leverages cycle iteration acceleration to get a representation of store buffers on paths which would form cycles if values in store buffers were disregarded.
It does not, however, target any real-world programming language.
Instead, it targets a modified Promela language~\cite{Holzmann1997}.
Another unbounded approach is presented in~\cite{Bouajjani2015} -- it introduces TSO behaviors lazily by iterative refinement, and while it is not complete, it should eventually find all errors.

\paragraph{Other Methods}\label{other-methods}

In~\cite{Park1995}, the SPARC hierarchy of memory models (TSO, PSO, RMO) is modeled using encoding from assembly to Mur\(\varphi\)~\cite{Murphi}.
In~\cite{Huynh2006} an explicit state model checker for C\# programs (supporting subset of C\#/.NET bytecode) which uses the .NET memory model is presented.
The verifier first verifies program under SC and then it explores additional runs allowed under the .NET memory model.
The implementation of the exploration algorithm uses a list of delayed instructions to implement instruction reordering.
The work~\cite{Dan2013} presents verification of (potentially infinite state space) programs under TSO and PSO (with bounded store buffers) using predicate abstraction.

A completely different approach is taken in~\cite{Turon2014}.
This work introduces a separation logic GPS, which allows proving properties about programs using (a fragment of) the C11 memory model.
That is, this work is intended for manual proving of properties of parallel programs, not for automatic verification.
The memory model is not complete; it lacks relaxed and consume-release accesses.
Another fragment of the C11 memory model is targeted by the RSL separation logic introduced in~\cite{Vafeiadis2013}.

\section{Termination of Parallel Programs}

For the related work, we consider only results which go beyond safety checking.
There are many approaches to find problems such as assertion violations or memory safety violations, but they are fundamentally limited to properties concerning finite runs of the program, and we are focusing here on an infinite behaviour, namely on the absence of termination.
Similarly, we do not mention techniques which specialise on checking sequential programs and have no support for parallelism, as well as techniques which are tailored to a specific modelling language and cannot be applied in general.

Several techniques for checking properties other than safety exist -- indeed
usage of various temporal logics, such as Linear Temporal Logic (LTL)
\cite[Chapter 5]{PoMC} and Computation Tree Logic (CTL) \cite[Chapter 6]{PoMC} in the context of model checking dates way back to the beginning of research in formal methods.
Unfortunately, these techniques are not often applied to programs written in real-world programming languages such as C and C++.

As for techniques which detect nontermination, both static and dynamic
techniques exist for the detection of deadlocks caused by circular waiting for
mutexes~\cite{CC14,agarwal2010detection,bensalem2005scalable}.
However, these techniques specialise on mutexes and do not allow general nontermination detection, and it is unlikely that they could be naturally extended to cover it.
There are also techniques that detect deadlocks of the whole program (i.e., a program state from which the program cannot move) \cite{Chaki2005,Demartini99}, but these techniques cannot find cases in which only some threads of the program are making progress, while other threads are blocked forever.
Also, these global deadlock detection techniques are inadequate in the presence of synchronisation mechanisms which causes busy waiting instead of blocking (for example spin locks) or in the cases when normally blocking operations are implemented using busy waiting (which can be easier to handle for the verifier in some cases).
A somewhat different approach based on communicating channels is proposed in \cite{Ng2016}, but this approach is aiming at the Go programming language which primarily uses shared channels for communication between threads.
Overall, neither of these techniques is applicable in general for the detection of nontermination in programs which use a combination of synchronisation primitives in shared memory.
Finally, there are also techniques for checking termination of sequential programs, to name a few \cite{Giesl2017,Chen2018}.

\section{Benchmark Suites}

% vim: colorcolumn=80 expandtab sw=4 ts=4 spell spelllang=en
