Historically, automatic analysis techniques for parallel programs started with
analysis of models of systems.
A programmer wishing to use such a tool would either start by creating a model
of the system (in the specification step of the development), and then provide
an executable implementation for this model or, if they already had a working
product, they would have to create a model in order to analyze it.
Such tools include for example \cite{spin}, \cite{divine-mc}, \cite{ltsmin?}, \cite{uppall?}, \cite{TODO...}.
Such an approach requires an extra investment in the modelling phase and, even
if analysis of the model concludes it is correct, it does not prove that the
final product is indeed correct.

Later, with the improvement of both analysis techniques, as well as overall
improvement in available computing power, tools which analyse programs written
in mainstream programming languages become available.
Early examples of such tools are \TODO{…}.

Since 2012, the Software Verification Competition (SV-COMP)~\cite{svc2020} aims
to showcase tools which support direct verification of software written in C
and Java.
While it includes mostly sequential programs, there is also a subcategory for
parallel C programs in SV-COMP.

We will now focus in more details on automatic techniques for verification of
parallel programs.
We will not consider program analysis techniques which require substantial manual effort (e.g., proof-theorem-based techniques), or techniques which are not applicable to realistic programs (e.g., techniques which use a special modelling language).
We will also mostly disregard tools with no support for parallel programs.

\section{Explicit-State Model Checking}

Explicit-state model checking is based on exhaustive exploration of the
state-space graph \cite{TODO}.
It checks that a given (finite-state) system satisfies given property.
The property is often given by an LTL formula and the automata-based approach
to LTL verification is used (i.e., the problem is reduced to the problem of
repeated reachability of a state in the state-space graph).
In the special case of safety properties, it is sufficient to perform graph
search for a state which violates the safety property, for example using the
depth-first search algorithm, or any other graph search.

The advantage of explicit-state model checking is that it is conceptually easy
to apply it to verification of parallel programs, as the interleaving semantics
of thread naturally gives rise to the state space graph. \TODO{...?}

In practice, explicit-state model checking is prone to the \emph{state-space
explosion} problem: the number of states in the state-space graph of a
reasonable system can easily be so big it is not possible to store the state
space in the available memory.
Since the algorithm which explores the state-space graph needs to detect which
states were already seen to ensure termination, the state space explosion
problem can significantly limit capabilities of explicit-state model checking.

To mitigate state-space explosion, several state-space reduction techniques
were introduced.
Using these techniques, it is possible to explore only some of the states of
the state space in such a way that the property holds for these states if and
only if it holds for the entire state space.
These reduction techniques include \emph{Partial Order Reduction} (POR), which
can eliminate some states by exploring independent events only in one
particular order \cite{Pele1993,Godefroid1996partial, TODO}.
\TODO{...}

Another wide family of reductions are reductions which can coalesce a path in a
state space into a single edge and hide all intermediate states.
This idea was introduced by Lipton in~\cite{Lipton1975}, who introduced the
notion of right movers (``resource acquire operations'') and left movers
(``resource release operations'') to identify statements in program which can
be executed atomically.
However, in analysis of realistic parallel programs a notion of instruction (or
action) visibility is often used -- a group of instructions from one thread can
be executed atomically provided that at most one of them is visible to other
threads and that this grouping does not influence checking of the verified
property.
Both static and dynamic reduction methods were proposed, under many names,
including D-reduction~\cite{Lipton1975}, path reduction~\cite{Yorav2004}, $\tau$ reduction~\cite{BBR2012}, \TODO{…} for the static variants and $\tau+$ reduction~\cite{RBB13} and \cite[Section 6]{RSCB2018}, \TODO{...} for the dynamic once.
Quite naturally, the dynamic methods are better suited for the complex control-
and data-flow of realistic programs.

Finally, there are variants of \emph{symmetry reductions} which reduce the
state space by coalescing states which differ only in properties not relevant
for the program analysis.
For example the \emph{heap-symmetry} reduction allows to consider two states
that differ only in the order in which memory objects were allocated to be the
same~\cite{RBB13}, \cite[Chapter 6]{RSCB2018}, \cite{TODO}.
A dead-variable reduction~\cite{Yorav2004,Yorav2004:4,TODO} can be also seen as an instance of symmetry reductions.
\TODO{...}

These state space reduction techniques can reduce the number of states by
several orders of magnitude~\cite{TODO}, and therefore enable verification of
realistic (but still relatively small) programs.

\TODO{Interestingly, the proposed reduction techniques which aim to preserve verified properties are not always correct, for example the original version of $\tau+$ reduction considered only stores visible, but it was later shown that repeated loads have to be also visible (shown by me in~\cite{S2016}, acknowledged an fixed in \cite[Section 6]{RSCB2018}).
Similar problem was present in \cite{Cordeiro2011} where ESBMC could perform two conditional jumps which read the same shared variable with no context switch between them (section 3.1, rule R3).
Interestingly, the authors notice the possibility of missing context switches, but only introduce an option to fix it.}

To further improve capabilities of explicit-state model checking, several
techniques for compact representation of the set of visited states were
introduced.
These techniques include \emph{hash compaction}~\cite{TODO}, which is an
incomplete technique which stores hashes of states instead of storing the
entries states (and therefore can omit some parts of the state space if there
is hash collision), \emph{probabilistic storage of states}\TODO{...}, and
\emph{lossless compression techniques}~\cite{RSB15TC,TODO}.

\TODO{data} While explicit-state model checking can easily represent
control-flow nondeterminism, it is not well suited for data nondeterminism, as
it is not practical to explicitly enumerate all possible values of data
domains.
Therefore, if data nondeterminism is required, it is required to combine explicit-state model checking with some technique for symbolic of abstract data representation \TODO{...}.

\paragraph{Tools}

Among the various tools which use explicit-state model checking as its basis,
there are SPIN~\cite{Holzmann1997,Holzmann2004}, \textsc{LTSmin}~\cite{TODO}, Java Path Finder (JPF)~\cite{TODO}, \TODO{...}, and our own tool DIVINE~\cite{DIVINEToolPaper2017}.
SPIN targets primarily a modelling language PROMELA, but there is also an extension of SPIN to partial support of C, with the need to define a PROMELA driver~\cite{Zaks2008}.

DIVINE uses dynamic $\tau+$ reduction~\cite{TODO}, heap symmetry reduction, and
efficient representation of state space by memory graphs~\cite{RSCB2018}, to
tackle realistic programs.
Furthermore, DIVINE has support for symbolic and abstract representation of
data~\cite{TODO}, can analyse programs running under the \xtso memory model
(\autoref{chap:mm}, \cite{SB2018x86tso}), and can detect nontermination of
parallel programs (\autoref{chap:lnterm}, \cite{SB2019}).
DIVINE has also good support for the C and C++ languages, including support for
the standard libraries and C++ exceptions (\autoref{chap:lang},
\cite{SRB2017}).

\section{Stateless Model Checking}

Compared to explicit-state model checking, stateless model checking (SMC)
avoids storing the set of visited states and therefore has decreased memory
consumption.
Furthermore, since the state representation is not required to be as compact as
possible, stateless model checker can have simpler representation of states.
Stateless model checking was introduced in~\cite{Godefroid1997}, it aims at
safety analysis of terminating parallel programs.
A stateless model checker usually explores the state space in depth-first
manner and it can explore some parts of the state space multiple times (since
it does not store the set of visited states).
Therefore, the requirement that input program is terminating is is necessary
to ensure the verification procedure terminates.
In practice, this requirement is often ensured by imposing loop iteration
bounds -- loops are assigned maximum allowed number of iterations, if the
program under test requires more iterations of some loop, the loop bound can be
increased, or the analysis can be terminated as inconclusive.

Without additional state space reductions, SMC would lead to redundant
explorations of many parts of the state space -- in parallel programs it is
common that two or more actions of different threads are independent and
regardless of their order they lead to the same end state.
In this case a stateless model checker would explore a state as many times as
is the number of paths from the initial state to this state (in the worst case
the number of paths to a given state can be exponential to its distance from
the initial state).
To mitigate this problem, dynamic partial order reduction
(DPOR)~\cite{Flanagan2005dpor} is employed with SMC.
DPOR is a version of partial order reduction that tightly integrates with
the SMC exploration algorithm and keeps track of parts of the state space which
still need to be explored.
Using DPOR, SMC can avoid redundant exploration of equivalent paths in the
state space.

Many works are concerned with design of efficient DPOR methods both for
parallel programs running under sequential consistency (interleaving
semantics), and for various memory models.
This is usually accomplished by combination of two aspects: an equivalence of
traces and an exploration algorithm which ensures at least one trace (and in
optimal case exactly one trace) from each equivalence class is explored.
The trace equivalence has to be designed in such a way that for each of its
classes either all traces contain only safe states or all traces contain an
unsafe state -- i.e., the equivalence preserves safety properties.

For sequential consistency, multiple DPOR techniques were introduced.
\TODO{Verisoft, CHESS, techniky} \cite{TODO,TODO}, among these \cite{Abdulla2014} is interesting by providing an optimal algorithm for equivalence based on \emph{Mazurkiewicz trace} \cite{Abdulla2014:17} (where traces are considered equivalent if one of them can be obtained from the other by swapping adjacent non-conflicting execution step..).
While the original implementation of the is technique was used for verification of Erlang programs (which use message passing instead of shared variables) using the Concuerror tool, it was later successfully applied also to verification of C programs under TSO and PSO memory models using the Niddhugg SMC \cite{Abdulla2017tso}, a simpler, non-optimal version proposed in the original paper is also implemented in the Skink SMC~\cite{Cassez2017}.

It is important to note that the optimal DPOR presented by \cite{Abdulla2014}
is optimal for the given trace equivalence.
Later a data-centric DPOR which uses a coarser equivalence and an optimal
exploration algorithm for it was introduced in~\cite{Chalupa2017} and it was
shown that it performs better on a selection of C benchmarks.

Another approach based on observation of read and written values is Maximal
Causality Reduction (MCR)~\cite{Huang2015}, which can be seen as an alternative
to DPOR.
MCR employs an SMT solver to find new traces to explore which allows it to
explore less interleavings then Mazurkiewicz-trace-based DPOR techniques.
Another advantage of MCR is that it can be easily modified for parallel
exploration (DPOR cannot be easily executed in parallel).

\TODO{...?}

\paragraph{Relaxed Memory Models}

Thanks to its ability to reduce exploration of redundant interleavings, SMC
combined with DPOR or other reduction techniques is often used as a basis for
analysis of programs running under various relaxed memory models.

Several approaches focus on the TSO/\xtso memory models (and often also on PSO,
which is somewhat more relaxed then TSO, but can usually be simulated in a
similar manner).
These include \emph{rInspect} presented in~\cite{Zhang2015}, which uses store
buffers and shadow threads which flush them to integrate relaxed memory with
existing DPOR approaches for sequential consistendy.
The tool \emph{rInspect} is based on LLVM and targets primarily C programs.
It has support for both bounded and unbounded store buffers (but being a SMC it
works on terminating programs only).
Another approach to TSO and PSO is used by tool Niddhugg and presented
in~\cite{Abdulla2015}.
This approach uses chronological traces that capture dependencies between
memory operations.
Chronological traces are then used with the optimal DPOR
from~\cite{Abdulla2014}, which gives rise to an interesting property -- for
robust programs (i.e., programs which do not exhibit observable relaxed
behaviour) the number of traces explored under TSO or PSO should be the same as
the number of traces explored under sequential consistency.
Niddhugg is an LLVM-based tool for analysis of C programs.
A SAT-based stateless approach is presented in~\cite{Demsky2015}.
It targets both sequential consistency and \xtso and is implemented in the tool
SATCheck.
It repeatedly executes a concrete interleaving of threads (and records
dependencies in this execution) and invokes SAT solver to find new
interleavings with different behaviour.

For the C11/C++11 memory model~\cite{Norris2013} presents a tool \textsc{CDSChecker}.
It covers most of the C11 memory model, with the exception of release-consume
synchronization and executions which exhibit out-of-thin-air
values.\mnote{Out-of-thin-air values \TODO{...}.}
To allow reads which are reordered with future operations (which is allowed by
the C11 memory model), \textsc{CDSChecker} can propagate stored values to
previous loads and validate this speculation.
\textsc{CDSChecker} targets primarily unit tests of concurrent data structures
written in C11/C++11.
A different approach to stateless model checking of programs running under the
C11/C++11 memory model is taken in~\cite{Kokologiannakis2017}.
This approach uses the RC11 memory model, which is a proposed memory model
which fixes some of the problems with the C11/C++11 memory
model~\cite{Lahav2017}.
Here, the authors use execution graphs which represent visible program actions
and dependencies between them to explore all behaviour of a given program.
This allows them to cover all program's behaviour without direct exploration of
its interleavings.
The approach is implemented in the tool RCMC.


In~\cite{Abdulla2016} an approach for stateless model checking under the POWER memory model is show.
The work presents a way to derive a suitable execution model from the axiomatic semantics of the memory model, and an SMC exploration algorithm for the execution model.
The proposed approach explores only a single complete trace from each equivalence class given by Shasha-Snir traces~\cite{Shasha1988}, but it can perform redundant exploration of incomplete traces. 
The algorithm is implemented in the tool Niddhugg.


---

CHESS:
- state hashing (according to \cite{Cordeiro2011})


SATABS (unknown type)
- according to \cite{Cordeiro2011} cannot handle arrays + arithmetic



\paragraph{Limitations of SMC}

- deteministic threads: \cite{Huang2015:14,Huang2015:27}.


\section{Bounded Model Checking}

\TODO{Symbolic MC without BDDs}

CBMC \cite{Kroening2014}, \cite{Clarke2004}
- bit-precise BMC for C
- SAT based
- assertions + instrumentation for other properties (safety only)
- unrolling bound
- parallelism, weak (SC, x86, POWER), uses partial orders  for efficient encoding of parallelism \cite{Alglave2013por} instead of interleavings (\TODO{? :30, :36, :6})
  - the formula is build from SSA form of each thread and ordering constraints for shared variables
- relaxed memory has little impact on performance
- SC: \cite{Alglave2013por:25}
- SV-COMP
- custom C frontend
- k-induction?? (\cite{Gadelha2018:7})

\textsc{Yogar-CBMC} \cite{Yin2018}, \cite{Yin2019}
- parallelism, SC only
- can run in parallel
- abstraction and refinement of the encoding of scheduling constraints (which is normally cubic), multiple counterexample-guided refinements run at once, sharing the learned constraints

CBMC Path~\cite{Khazem2019}
- encodes program to SAT a single path a time
- aimed at faster bug discovery, especially for shallow bugs
- performed poorly in SV-COMP even on buggy benchmarks only

JBMC~\cite{Cordeiro2019}, \cite{Cordeiro2018}
- Java + exact verification-friendly model of most common parts of its standard libraries
- supports exceptions (lowering to goto)
- assertions, memory errors, integer overflows, type casting errors
- SAT+SMT, bit-precise
- shares BMC engine with CBMC
- dedicated solver for string operations
- no JNI, reflection, parallelism (in progress)

LLBMC~\cite{Merz2012}, \cite{Falke2013}
- BMC for C and C++
- based on the LLVM infrastructure, uses LLVM IR
- SMT based, bit-precise
- no floats, (C++) exceptions, RTTI
- overflows, invalid shifts, memory errors, memory leaks, assertions

LLVMVF~\cite{Sousa2013}
- for parallel programs, LLVM based
- generic framework on which the BMC is built
- input is LLVM IR
- no condition variables
- no threads
- not actively maintained \TODO{ověřit}

\paragraph{Sequentialization}

\TODO{\cite{Qadeer2004}}

Lazy-CSeq~\cite{Inverso2014}
- sequentialization of C programs: multi-threaded program -> nondeterministic sequential proram (source-to-source transformation)
- context bounded, round-robin schedules with given bound on round number
- designed to minimize memory overhead and sources of nondeterminism
- error checking is deffered to the backend
- uses CBMC as a backend (can use other BNCs: ESBMC, LLBMC, BLITZ)
- the formula size if O(|orig prog.| * |n threads| * |n rounds|)
- Lazy = explores only reachable state space (compared to Akash Lal \& Thomas Reps: Reducing concurrent analysis under a context bound to sequential analysis), does not start after each context switch from nondeterministic values

MU-CSeq~\cite{Tomasco2015}, \cite{Tomasco2016}
- memory unwinding (MU) = sequence of write operations to the shared memory
- MU is nondeterministically guessed, the program is allowed to run such that it respects the MU
- = bounded number of write operations 
  - either all write operations, or only some selected as visible to other threads are part of the unwinding
- later IMU = individual memory location unwinding
  - separate sequence for each location + timestamp of writes
- uses CBMC as a backend
- source-to-source transformation for C
- support for dynamic memory added in~\cite{Tomasco2016}
- eager = threads are executed separately, with nondeterministic values for shared memory reads, runs are pruned
- IMU-CSeq~\cite{Tomasco2017}
  - relaxed memory models (TSO, PSO)
  - shared memory abstraction (SMA) = definition of memory operations + synchronization primitives (different SMA -> different memory model)

\paragraph{Limitations of BMC}

- C programs
- bounded depth
- functions inlined (… function pointers)/recursion bound

\section{K-Induction, IC3, …}

\paragraph{$k$-Induction}

$k$-induction is an extension of bounded model checking which allows it to find bugs faster and to prove correctness of programs without unwinding loops fully.
A BMC with $k$-induction repeatedly performs three steps with an increasing bound $k$:
\begin{description}
    \item[Base Case] checks if an error is reachable in $k$ steps.
    \item[Forward Condition] checks if all program's paths had terminated in $k$ steps (i.e., the verification is done as the tool had already explored all states)
    \item[Inductive Step] checks that in a modified program in which all loop variables are initialized to nondeterministic values before the loops and the loops are required to execute to completion,\mnote{This can be achieved by instrumenting \texttt{assume} statements which ensure that the loop body is entered and that after the given number of iterations the condition for loop termination holds.} if the safety property holds for the first $k$ steps, it also holds for $k+1$ steps. If the induction step holds the program is correct.
\end{description}
Invariants can be used to strengthen the induction by constraining the nondeterministic values of loop variables.
\cite{Cordeiro2016:23-27}

ESBMC~\cite{Gadelha2019}, \cite{Gadelha2018}
- C programs
- SMT-based BMC + k-induction + invariant generation based on intervals for integral variables (to guide the inductive step)
- interval analysis cannot handle pointers and is incorrect with them
- context-bounded - the number of context switches is limited
- context switches only at visible instructions (access of shared memory)
- clang-based frontend (uses AST, not LLVM)
- assertions, memory errors, overflow, deadlocks
- (uses a symbolic execution when generating formula \& unrolling (so does CBMC))
- approach to threading is described in~\cite{Cordeiro2011} (the tree of possible interleavings is explored explicitly, variable constraints are only collected but not resolved, encoded by paths (= lazy; each interleaving uses a seperate single-threaded BNC instance) or together (= schedule recording, using guards to encode scheduling of the interleavings), or an algorithm based on approximation and widening~\cite{Grumberg2005} can be used (=underapproximation+widening; which uses series of under-approximations refined based on proofs of unsatisfiability of the formula which represents the runs of the programs with the property. Should guide the checker to interleavings interesting for the formula. The formula still encodes all interleavings, but only some of them can be used.) lazy is best, then scheduler, UW is slowest (probably due to proof generation).
- \cite{Cordeiro2016}: analysis of challenges of BMC
- support for C++: ESBMC++~\cite{Ramalho2013}
  - abstract representation of C++ libraries (= operational model; conservative appriximation of library behaviour)
  - exception handling, inheritance (modelling of objects)
  - GCC/g++ based parser
  - later a Qt object model was added~\cite{Sousa2015},~\cite{Garcia2016}: tool $\text{ESBMC}^{\mathit{Qt}OM}$
    - partial support for the Qt framework for C++ programs
    - model based on documentation


DepthK~\cite{Rocha2017}, \cite{Rocha2017svc}
- BMC + k-induction + polyherdral invariants
- a preprocessor for ESBMC, it uses an external tool for invariant generation
- C programs, parallelism

\cite{Donaldson2011}: \textsc{K-Inductor}, \textsc{K-Boogie}
<- CBMC based
-> extension of Boogie
- \TODO{...}


\section{Symbolic Execution}

\section{Abstraction-Based Techniques}

\section{Sequentialization Techniques}

\section{Systematic Testing}

\section{Control-Flow Analysis Techniques}

\section{XXX}

\section{Real-World Parallel Programs}


\section{Relaxed Memory Models}

There are numerous techniques for analysis of programs with respect to relaxed memory.

\paragraph{Verification of Absence of SC Violations}

For these methods, the question is whether a program, when running under a relaxed memory model, exhibits any runs not possible under sequential consistency.
This problem is explored under many names, e.g. (TSO-)safety~\cite{Burckhardt2008}, robustness~\cite{Bouajjani2013,Derevenetc2014}, stability~\cite{Alglave2011}, and monitoring of sequential consistency~\cite{Burnim2011}.
A similar techniques are used in \cite{Yang2004} to detect data races in Java programs.
A related problem of correspondence between a parallel and sequential implementation of a data structure is explored in~\cite{Ou2017}.
Some of these techniques can also be used to insert memory fences into the programs to recover sequential consistency.

Neither of these techniques is directly comparable to our method.
For these techniques, a program is incorrect if it exhibits relaxed behavior, while for us, it is incorrect if it violates specification (e.g., assertion safety and memory safety).
In practice, the appearance of relaxed behavior is often not a problem, provided the overall behavior of the data structure or algorithm matches desired specification.
In many lock-free data structures, a relaxed behavior is essential to achieving high performance.

\paragraph{Direct Analysis Techniques}

There are multiple methods for analysis of relaxed memory models based on program transformation.
In~\cite{Alglave2013} a transformation-based technique for the x86, POWER, and ARM memory models is presented.
Another approach to program transformation is taken in~\cite{Atig2011}, in this case, the transformation uses context switch bounding but not buffer bounding, and it uses additional copies for shared variables for TSO simulation.
In~\cite{Abdulla2017} the context-bounded analysis using transformation is applied to the POWER memory model.
Our work in~\cite{SRB15weakmem} presents a transformation of LLVM bitcode to simulate buffer-bounded \xtso runs; compared to this work it has significantly less efficient implementation of the \xtso simulation.


So far, all of the described techniques used some kind of bounding to achieve efficiency -- either bounding number of reordered operations, number of context switches, or number of iterations of loops.
An unbounded approach to verification of programs under TSO is presented in~\cite{Linden2010}.
It uses store buffers represented by automata and leverages cycle iteration acceleration to get a representation of store buffers on paths which would form cycles if values in store buffers were disregarded.
It does not, however, target any real-world programming language.
Instead, it targets a modified Promela language~\cite{Holzmann1997}.
Another unbounded approach is presented in~\cite{Bouajjani2015} -- it introduces TSO behaviors lazily by iterative refinement, and while it is not complete, it should eventually find all errors.

\paragraph{Other Methods}\label{other-methods}

In~\cite{Park1995}, the SPARC hierarchy of memory models (TSO, PSO, RMO) is modeled using encoding from assembly to Mur\(\varphi\)~\cite{Murphi}.
In~\cite{Huynh2006} an explicit state model checker for C\# programs (supporting subset of C\#/.NET bytecode) which uses the .NET memory model is presented.
The verifier first verifies program under SC and then it explores additional runs allowed under the .NET memory model.
The implementation of the exploration algorithm uses a list of delayed instructions to implement instruction reordering.
The work~\cite{Dan2013} presents verification of (potentially infinite state space) programs under TSO and PSO (with bounded store buffers) using predicate abstraction.

A completely different approach is taken in~\cite{Turon2014}.
This work introduces a separation logic GPS, which allows proving properties about programs using (a fragment of) the C11 memory model.
That is, this work is intended for manual proving of properties of parallel programs, not for automatic verification.
The memory model is not complete; it lacks relaxed and consume-release accesses.
Another fragment of the C11 memory model is targeted by the RSL separation logic introduced in~\cite{Vafeiadis2013}.

\section{Termination of Parallel Programs}

For the related work, we consider only results which go beyond safety checking.
There are many approaches to find problems such as assertion violations or memory safety violations, but they are fundamentally limited to properties concerning finite runs of the program, and we are focusing here on an infinite behaviour, namely on the absence of termination.
Similarly, we do not mention techniques which specialise on checking sequential programs and have no support for parallelism, as well as techniques which are tailored to a specific modelling language and cannot be applied in general.

Several techniques for checking properties other than safety exist -- indeed
usage of various temporal logics, such as Linear Temporal Logic (LTL)
\cite[Chapter 5]{PoMC} and Computation Tree Logic (CTL) \cite[Chapter 6]{PoMC} in the context of model checking dates way back to the beginning of research in formal methods.
Unfortunately, these techniques are not often applied to programs written in real-world programming languages such as C and C++.

As for techniques which detect nontermination, both static and dynamic
techniques exist for the detection of deadlocks caused by circular waiting for
mutexes~\cite{CC14,agarwal2010detection,bensalem2005scalable}.
However, these techniques specialise on mutexes and do not allow general nontermination detection, and it is unlikely that they could be naturally extended to cover it.
There are also techniques that detect deadlocks of the whole program (i.e., a program state from which the program cannot move) \cite{Chaki2005,Demartini99}, but these techniques cannot find cases in which only some threads of the program are making progress, while other threads are blocked forever.
Also, these global deadlock detection techniques are inadequate in the presence of synchronisation mechanisms which causes busy waiting instead of blocking (for example spin locks) or in the cases when normally blocking operations are implemented using busy waiting (which can be easier to handle for the verifier in some cases).
A somewhat different approach based on communicating channels is proposed in \cite{Ng2016}, but this approach is aiming at the Go programming language which primarily uses shared channels for communication between threads.
Overall, neither of these techniques is applicable in general for the detection of nontermination in programs which use a combination of synchronisation primitives in shared memory.
Finally, there are also techniques for checking termination of sequential programs, to name a few \cite{Giesl2017,Chen2018}.

\section{Benchmark Suites}

- \cite{Sarkar2011}, \cite{MadorHaim2012} POWER tests
- http://www.cprover.org/wmm/
- ESBMC (\cite{Cordeiro2011}): http://users.ecs.soton.ac.uk/lcc08r/esbmc/
- ESBMC++ \cite{Ramalho2016:19,6,27,.} (sec. IV.A. Experimental Setup)

\section{MISC}

- need for environemnt and application intefrace modelling: \cite{Cordeiro2016}

% vim: colorcolumn=80 expandtab sw=4 ts=4 spell spelllang=en
